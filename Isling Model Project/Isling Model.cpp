#include <iostream>
#include <random>
#include <vector>
#include <string>
#include <map>
#include<fstream>

using namespace std;



/* This template class is used for measuring the average energy and magnetisation of the lattice
during the simulation. Since the sequence of measurements is generated by MCMC, they have 
autocorrelation. To allow the calculation of the error on measurements of the average using the 
standard deviation of the mean (SDOM), the observations need to be independent. By using data binning on 
the measurement observations at regular intervals that are greater than the autocorrelation time, 
we can then average these bins, which preserves the mean of the whole sequence. The averages 
of the bins are then used to calculate the SDOM. */


template <class Type> class average_tracker{
	
public:

private:
int bin_size;
		int count;
		int no_of_bins;
Type av;
vector<double> bins;

public:
	average_tracker() : bin_size(1000),count(0),no_of_bins(0) {}
	average_tracker(int bsz) : bin_size(bsz),count(0),no_of_bins(0) {}

	// Add a new observation to the current bin average of the average tracker object
	void push(const Type v){
		if (count == 0)
		{
			av = v;
			count += 1;
		}
		else if (count < bin_size-1)
		{
			av += v;
			count += 1;
		}
		else
		{
			/* If bin_size has been exceeded, make a new bin and finish off the average calculation
			of the old one*/
			av += v;
			bins.push_back(((double) av)/bin_size);
			count = 0;
			no_of_bins += 1;
		}

	}

	// Gives the grand average over all the bins in the object
	double average()
	{
		double res = 0.0;
		for (auto r : bins) res += r;
		return (res/no_of_bins);
	}

	// Calculates the SDOM for each bin in the object
	double error_average(){
		double res = 0.0, res2 = 0.0;
		for (auto r : bins)
		{
			res += r;
			res2 += pow(r,2);
		}
		res = res/no_of_bins;
		res2 = res2/no_of_bins;

		return pow((res2 - pow(res,2))/(no_of_bins-1),0.5);
	}

};


// Function that is used to flip the spin of a given position on the lattice

vector<vector<int>> flip_spin(vector<vector<int>> lat, int i_index, int j_index){
	if (lat[i_index][j_index] == 1)
	{
		lat[i_index][j_index] = -1;
	}
	else
	{
		lat[i_index][j_index] = 1;
	}

	return lat;
}

// Function that is used to calculate the total magnetisation of the lattice at a timestep

int magnetisation(vector<vector<int>> lat){
	int s = 0;
	int L = lat.size();

	for (int i = 0; i < L; ++i)
	{
		for (int j = 0; j < L; ++j)
		{
			s += lat[i][j];
		}
	}

	return s;
}


// Function that is used to calculate the total energy of the lattice at a timestep

int energy(vector<vector<int>> lat, vector<int> nf){
	int s = 0;

	int L = lat.size();

	for (int i = 0; i < L; ++i)
	{
		for (int j = 0; j < L; ++j)
		{
			s += lat[i][j]*lat[i][nf[j]];
		}
	}

	for (int j = 0; j < L; ++j)
	{
		for (int i = 0; i < L; ++i)
		{
			s += lat[i][j]*lat[nf[i]][j];
		}
	}

	return -s;
}


// Function used to print the tracked energy and magnetisation moments into a file for later viewing.

void printout (average_tracker <double> E ,average_tracker <double> E_2 ,average_tracker <double> E_4 ,average_tracker <double> M ,average_tracker <double> M_2 ,average_tracker <double> M_4,string name) {
   
   
   ofstream file;
   file.open(name+".csv", std::ios_base::app);
   file << to_string(E.average()) <<","<< to_string(E_2.average())<<","<<to_string(E_4.average())
   <<","<<to_string(M.average())<<","<< to_string(M_2.average())<<","<<to_string(M_4.average())
   <<","<<to_string(E.error_average()) <<","<<to_string(M.error_average())<< "\n";

   file.close();
}


/* This function creates the square lattice of size L x L by uniformly choosing the initial up or down
states and returning the lattice which is stored as a vector of vectors.*/

vector<vector<int>> initialize_lattice (int L) {

	// Uniform pseudo-random number generator
	std::random_device RR;
	std::seed_seq seed{RR(), RR(), RR(), RR(), RR(), RR(), RR(), RR()};
	std::mt19937 engine(seed);
	std::uniform_real_distribution<> u(0,1);
 
    vector<vector<int>> lattice( L , vector<int> (L, 0));

    int spin_states[2] = {-1,1};
    int random_index;

	for (int i = 0; i < L; ++i)
	{
		for (int j = 0; j < L; ++j)
		{
			random_index = (int)(u(engine)*1000000) % 2;
			lattice[i][j] = spin_states[random_index];
		}
	}

    return lattice;
}


// This function performs a single timestep update of the entire lattice via metropolis' criterion 

vector<vector<int>> lattice_sweep (int N_sweeps, vector<vector<int>> lattice, int L, double T, map<int, double> exponential_values, std::vector<int> neighbour_forward) {

	int E_prev,E_flipped,delta_E;
	int random_i,random_j;
	double P_flip,r;

	// Uniform pseudo-random number generator
	std::random_device RR;
	std::seed_seq seed{RR(), RR(), RR(), RR(), RR(), RR(), RR(), RR()};
	std::mt19937 engine(seed);
	std::uniform_real_distribution<> u(0,1);

	for (int sweeps = 0; sweeps < N_sweeps; ++sweeps)
	{
		for (int K = 0; K < L*L; ++K)
			{


				// Choose a position randomly on the 2D lattice

				random_i = (int)(u(engine)*1000000) % L;
				random_j = (int)(u(engine)*1000000) % L;



				// Calculate the change in energy delta E associated with flipping its spin state


				E_prev = energy(lattice, neighbour_forward);
				
				lattice = flip_spin(lattice, random_i, random_j);
				E_flipped = energy(lattice, neighbour_forward);
				

				lattice = flip_spin(lattice, random_i, random_j);

				delta_E = E_flipped - E_prev;


				// Flip the spin with probability P_flip = min(1.,exp(-delta_E/(k_b*T)))

				P_flip = std::min(1.,exponential_values[delta_E]);
				r = u(engine);


				if (P_flip > r)
				{
					lattice = flip_spin(lattice, random_i, random_j);
				}

			}
	}
	

	return lattice;
}



int main(){

	// File names of where we will store the data for later viewing
	string lattice_file_name = "lattice_2";
	string energy_file_name = "energy_vector_2";
	string mag_file_name = "mag_vector_2";

	std::random_device RR;
	std::seed_seq seed{RR(), RR(), RR(), RR(), RR(), RR(), RR(), RR()};
	std::mt19937 engine(seed);
	std::uniform_real_distribution<> u(0,1);

	// Initial parameters of the model
	int L = 50;					// Length of a side of the square lattice
	int n_warmup = 85;			// Number of lattice sweeps before measurement begins to mitigate burn-in time
	double T = 2.2691853;		/* The temperature in natural units of k_b/J where k_b is boltzmann's constant.
								   The selected temperature is near the phase transition between the lattice
								   assuming a paramagnetic state with random ordering to the spins and a 
								   ferromagnetic state with uniform alignment of the spins.*/
	int n_step = 2;				// Number of sweeps done between measuring the lattice.
	int n_meas = 1000;			// Number of total measurements of the lattice.


	// A vector that allows more convient traversing of the torus topology of the lattice when iterating over it. 
	std::vector<int> neighbour_forward(L,0);
	for (int i = 0; i < L; ++i)
	{
		if (i!=(L-1))
		{
			neighbour_forward[i] = i + 1;
		}
		else
		{
			neighbour_forward[i] = 0;
		}
	}


	/* Pre-calculation of all needed values of the exponential function for usage in calculation of the 
	Boltzmann distribution draws during a lattice sweep to speed up the simulation.*/
	map<int, double> exponential_values;

	for (int i = -L; i < L+1; ++i)
	{
		exponential_values[i] = exp(-i/T);
	}


	// The size of the bins used in the binning technique as described by the average_tracker template class.
	int congifured_n_bins = 10;

	/* Creation of average_tracker objects which will track the first, second, and fourth moments of the energy and 
	magnetisation of the lattice */
	average_tracker <double> E (congifured_n_bins);
	average_tracker <double> E_2 (congifured_n_bins);
	average_tracker <double> E_4 (congifured_n_bins);
	average_tracker <double> M (congifured_n_bins);
	average_tracker <double> M_2 (congifured_n_bins);
	average_tracker <double> M_4 (congifured_n_bins);

	// Creation and labeling the columns of the CSV file used to track the energy and magnetisation moments.
    ofstream file;
    file.open(lattice_file_name+".csv");
    file << "E,E^2,E^4,M,M^2,M^4,E_err,M_err\n";
    file.close();


    // The vectors and variables used to measure and store the direct measurements of the lattice
	int E_measurement,M_measurement;
	vector<int> mag_vector;
	vector<int> energy_vector;


	// Creation of the lattice and doing the warmup sweeps
	vector<vector<int>> spin_configuration = initialize_lattice(L);
	spin_configuration = lattice_sweep(n_warmup,spin_configuration,L,T,exponential_values,neighbour_forward);

	// Measurement of the lattice until n_meas is reached.
	for (int meas = 0; meas < n_meas; ++meas)
	{	
		// Prints to terminal current progress of the measurements every 5th measurement done.
		if (((meas+1)%5) == 0)
		{
			std:: cout << "Measurement # " << to_string(meas+1) << endl;
		}


		// n_step sweeps of the lattice done in between measurements.
		spin_configuration = lattice_sweep(n_step,spin_configuration,L,T,exponential_values,neighbour_forward);

		
		// Measurement and storage of the measurements
		E_measurement = energy(spin_configuration,neighbour_forward);
		M_measurement = magnetisation(spin_configuration);

		// Storing raw measured values
		mag_vector.push_back(M_measurement);
		energy_vector.push_back(E_measurement);

		// Storing values into the average_tracker objects
		E.push(E_measurement);
		E_2.push(pow(E_measurement,2));
		E_4.push(pow(E_measurement,4));

		M.push(M_measurement);
		M_2.push(pow(M_measurement,2));
		M_4.push(pow(M_measurement,4));
		
		// Saving moment values to the lattice CSV file
		if (meas >= congifured_n_bins)
		{
			printout(E,E_2,E_4,M,M_2,M_4,lattice_file_name);
		}
		
	}


	// Saving raw measured values of magnetisation to the magnetisation vector CSV file
    file.open(mag_file_name+".csv");
    for (int i = 0; i < mag_vector.size(); ++i)
    {
    	file << mag_vector[i] << "\n";
    }

    file.close();


	// Saving raw measured values of energy to the energy vector CSV file
    file.open(energy_file_name+".csv");
    for (int i = 0; i < energy_vector.size(); ++i)
    {
    	file << energy_vector[i] << "\n";
    }

    file.close();

	
}